import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { fetchClient, requestSms } from "../api/clientApi";

import type { AppState, AppThunk } from "../store";
// import { fetchCount } from './../counterAPI'
import type { Client, OtpRequest, SignUpRequest } from "../../types/types";
import axios, { AxiosResponse } from "axios";

export interface ClientState {
  value: Client;
  status: "logedIn" | "loading" | "403" | "401" | "unknownError";
  token: "loading" | string;
  signInFlag:
    | "idle"
    | "request"
    | "loading"
    | "smsWaiting"
    | "smsCodeError"
    | "smsProviderError"
    | "smsNotSend"
    | "success"
    | "faild";
}

const initialState: ClientState = {
  value: {},
  status: "loading",
  token: "loading",
  signInFlag: "idle",
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const getclientAsync = createAsyncThunk(
  "client/fetchClient",
  async (clientId: string) => {
    const response:
      | Client
      | {
          error: {
            errorCode: any;
          };
        } = await fetchClient(clientId);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

export const signInRequestAsync = createAsyncThunk(
  "client/requestSms",
  async (OtpReq: OtpRequest) => {
    const response:
      | any
      | {
          error: {
            errorCode: any;
          };
        } = await requestSms(OtpReq.usernamebyphone);
    // The value we return becomes the `fulfilled` action payload
    console.log("response thunk", response);
    return response;
  }
);

export const clientSlice = createSlice({
  name: "client",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    signInRequest: (state, action: PayloadAction<OtpRequest>) => {
      state.signInFlag = "request";
      const getConfig = {
        headers: {
          "Cache-Control": "no-cache",
          "Content-Type": "application/json;charset=UTF-8",
          Accept: "*/*",
        },
      };
      const uri: string =
        "/api/sendotp" + `PhoneNumber=${action.payload.usernamebyphone}`;
      // const {data, status} = axios.get(uri, getConfig)
      // .then((Response: AxiosResponse) => {
      //   console.log("sms sended:", Response.data);
      //   if (Response.status < 300) state.signInFlag = "smsWaiting";
      // })
      // .catch((err) => {
      //   state.signInFlag = "smsProviderError";
      // });
    },
    // signIn: (state) => {},
    refreshToken: (state) => {},

    // setMobile: (state, action: PayloadAction<number>) => {
    //   // Redux Toolkit allows us to write "mutating" logic in reducers. It
    //   // doesn't actually mutate the state because it uses the Immer library,
    //   // which detects changes to a "draft state" and produces a brand new
    //   // immutable state based off those changes
    //   state.value.usernamebyphone = action.payload;
    // },
    // setUserInfo: (state, action: PayloadAction<Client>) => {
    //   state.value = action.payload;
    // },
    // fetchUserInfo: (state, action: PayloadAction<Client>) => {
    //   state.value = action.payload;
    // },
    // decrement: (state) => {
    //   state.value -= 1
    // },
    // // Use the PayloadAction type to declare the contents of `action.payload`
    // incrementByAmount: (state, action: PayloadAction<number>) => {
    //   state.value += action.payload
    // },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.

  extraReducers: (builder) => {
    builder
      .addCase(signInRequestAsync.pending, (state) => {
        state.signInFlag = "loading";
      })
      .addCase(signInRequestAsync.fulfilled, (state, action) => {
        state.signInFlag = "success";
      })
      .addCase(signInRequestAsync.rejected, (state, action) => {
        state.signInFlag = "smsCodeError";
      });
  },
});

export const { signInRequest } = clientSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectMobileNumber = (state: AppState) =>
  state.client.value.usernamebyphone;
export const selectUserInfo = (state: AppState) => state.client.value;
export const selectUserInfoStatus = (state: AppState) => state.client.status;
export const selectSignInFlag = (state: AppState) => state.client.signInFlag;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
// export const incrementIfOdd =
//   (amount: number): AppThunk =>
//   (dispatch, getState) => {
//     const currentValue = selectCount(getState())
//     if (currentValue % 2 === 1) {
//       dispatch(incrementByAmount(amount))
//     }
//   }

export default clientSlice.reducer;
